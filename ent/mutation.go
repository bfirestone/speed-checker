// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/bfirestone/speed-checker/ent/host"
	"github.com/bfirestone/speed-checker/ent/iperftest"
	"github.com/bfirestone/speed-checker/ent/predicate"
	"github.com/bfirestone/speed-checker/ent/speedtest"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeHost      = "Host"
	TypeIperfTest = "IperfTest"
	TypeSpeedTest = "SpeedTest"
)

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	hostname           *string
	port               *int
	addport            *int
	_type              *host.Type
	active             *bool
	description        *string
	clearedFields      map[string]struct{}
	iperf_tests        map[int]struct{}
	removediperf_tests map[int]struct{}
	clearediperf_tests bool
	done               bool
	oldValue           func(context.Context) (*Host, error)
	predicates         []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id int) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *HostMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HostMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HostMutation) ResetName() {
	m.name = nil
}

// SetHostname sets the "hostname" field.
func (m *HostMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *HostMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *HostMutation) ResetHostname() {
	m.hostname = nil
}

// SetPort sets the "port" field.
func (m *HostMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *HostMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *HostMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *HostMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *HostMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetType sets the "type" field.
func (m *HostMutation) SetType(h host.Type) {
	m._type = &h
}

// GetType returns the value of the "type" field in the mutation.
func (m *HostMutation) GetType() (r host.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldType(ctx context.Context) (v host.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *HostMutation) ResetType() {
	m._type = nil
}

// SetActive sets the "active" field.
func (m *HostMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *HostMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *HostMutation) ResetActive() {
	m.active = nil
}

// SetDescription sets the "description" field.
func (m *HostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HostMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[host.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HostMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[host.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HostMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, host.FieldDescription)
}

// AddIperfTestIDs adds the "iperf_tests" edge to the IperfTest entity by ids.
func (m *HostMutation) AddIperfTestIDs(ids ...int) {
	if m.iperf_tests == nil {
		m.iperf_tests = make(map[int]struct{})
	}
	for i := range ids {
		m.iperf_tests[ids[i]] = struct{}{}
	}
}

// ClearIperfTests clears the "iperf_tests" edge to the IperfTest entity.
func (m *HostMutation) ClearIperfTests() {
	m.clearediperf_tests = true
}

// IperfTestsCleared reports if the "iperf_tests" edge to the IperfTest entity was cleared.
func (m *HostMutation) IperfTestsCleared() bool {
	return m.clearediperf_tests
}

// RemoveIperfTestIDs removes the "iperf_tests" edge to the IperfTest entity by IDs.
func (m *HostMutation) RemoveIperfTestIDs(ids ...int) {
	if m.removediperf_tests == nil {
		m.removediperf_tests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.iperf_tests, ids[i])
		m.removediperf_tests[ids[i]] = struct{}{}
	}
}

// RemovedIperfTests returns the removed IDs of the "iperf_tests" edge to the IperfTest entity.
func (m *HostMutation) RemovedIperfTestsIDs() (ids []int) {
	for id := range m.removediperf_tests {
		ids = append(ids, id)
	}
	return
}

// IperfTestsIDs returns the "iperf_tests" edge IDs in the mutation.
func (m *HostMutation) IperfTestsIDs() (ids []int) {
	for id := range m.iperf_tests {
		ids = append(ids, id)
	}
	return
}

// ResetIperfTests resets all changes to the "iperf_tests" edge.
func (m *HostMutation) ResetIperfTests() {
	m.iperf_tests = nil
	m.clearediperf_tests = false
	m.removediperf_tests = nil
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Host, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, host.FieldName)
	}
	if m.hostname != nil {
		fields = append(fields, host.FieldHostname)
	}
	if m.port != nil {
		fields = append(fields, host.FieldPort)
	}
	if m._type != nil {
		fields = append(fields, host.FieldType)
	}
	if m.active != nil {
		fields = append(fields, host.FieldActive)
	}
	if m.description != nil {
		fields = append(fields, host.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldName:
		return m.Name()
	case host.FieldHostname:
		return m.Hostname()
	case host.FieldPort:
		return m.Port()
	case host.FieldType:
		return m.GetType()
	case host.FieldActive:
		return m.Active()
	case host.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldName:
		return m.OldName(ctx)
	case host.FieldHostname:
		return m.OldHostname(ctx)
	case host.FieldPort:
		return m.OldPort(ctx)
	case host.FieldType:
		return m.OldType(ctx)
	case host.FieldActive:
		return m.OldActive(ctx)
	case host.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case host.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case host.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case host.FieldType:
		v, ok := value.(host.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case host.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case host.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, host.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case host.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case host.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldDescription) {
		fields = append(fields, host.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldName:
		m.ResetName()
		return nil
	case host.FieldHostname:
		m.ResetHostname()
		return nil
	case host.FieldPort:
		m.ResetPort()
		return nil
	case host.FieldType:
		m.ResetType()
		return nil
	case host.FieldActive:
		m.ResetActive()
		return nil
	case host.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.iperf_tests != nil {
		edges = append(edges, host.EdgeIperfTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeIperfTests:
		ids := make([]ent.Value, 0, len(m.iperf_tests))
		for id := range m.iperf_tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removediperf_tests != nil {
		edges = append(edges, host.EdgeIperfTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeIperfTests:
		ids := make([]ent.Value, 0, len(m.removediperf_tests))
		for id := range m.removediperf_tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearediperf_tests {
		edges = append(edges, host.EdgeIperfTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeIperfTests:
		return m.clearediperf_tests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeIperfTests:
		m.ResetIperfTests()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// IperfTestMutation represents an operation that mutates the IperfTest nodes in the graph.
type IperfTestMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	timestamp           *time.Time
	sent_mbps           *float64
	addsent_mbps        *float64
	received_mbps       *float64
	addreceived_mbps    *float64
	retransmits         *float64
	addretransmits      *float64
	mean_rtt_ms         *float64
	addmean_rtt_ms      *float64
	duration_seconds    *int
	addduration_seconds *int
	protocol            *string
	success             *bool
	error_message       *string
	daemon_id           *string
	clearedFields       map[string]struct{}
	host                *int
	clearedhost         bool
	done                bool
	oldValue            func(context.Context) (*IperfTest, error)
	predicates          []predicate.IperfTest
}

var _ ent.Mutation = (*IperfTestMutation)(nil)

// iperftestOption allows management of the mutation configuration using functional options.
type iperftestOption func(*IperfTestMutation)

// newIperfTestMutation creates new mutation for the IperfTest entity.
func newIperfTestMutation(c config, op Op, opts ...iperftestOption) *IperfTestMutation {
	m := &IperfTestMutation{
		config:        c,
		op:            op,
		typ:           TypeIperfTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIperfTestID sets the ID field of the mutation.
func withIperfTestID(id int) iperftestOption {
	return func(m *IperfTestMutation) {
		var (
			err   error
			once  sync.Once
			value *IperfTest
		)
		m.oldValue = func(ctx context.Context) (*IperfTest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IperfTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIperfTest sets the old IperfTest of the mutation.
func withIperfTest(node *IperfTest) iperftestOption {
	return func(m *IperfTestMutation) {
		m.oldValue = func(context.Context) (*IperfTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IperfTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IperfTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IperfTestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IperfTestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IperfTest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *IperfTestMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *IperfTestMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *IperfTestMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetSentMbps sets the "sent_mbps" field.
func (m *IperfTestMutation) SetSentMbps(f float64) {
	m.sent_mbps = &f
	m.addsent_mbps = nil
}

// SentMbps returns the value of the "sent_mbps" field in the mutation.
func (m *IperfTestMutation) SentMbps() (r float64, exists bool) {
	v := m.sent_mbps
	if v == nil {
		return
	}
	return *v, true
}

// OldSentMbps returns the old "sent_mbps" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldSentMbps(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentMbps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentMbps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentMbps: %w", err)
	}
	return oldValue.SentMbps, nil
}

// AddSentMbps adds f to the "sent_mbps" field.
func (m *IperfTestMutation) AddSentMbps(f float64) {
	if m.addsent_mbps != nil {
		*m.addsent_mbps += f
	} else {
		m.addsent_mbps = &f
	}
}

// AddedSentMbps returns the value that was added to the "sent_mbps" field in this mutation.
func (m *IperfTestMutation) AddedSentMbps() (r float64, exists bool) {
	v := m.addsent_mbps
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentMbps resets all changes to the "sent_mbps" field.
func (m *IperfTestMutation) ResetSentMbps() {
	m.sent_mbps = nil
	m.addsent_mbps = nil
}

// SetReceivedMbps sets the "received_mbps" field.
func (m *IperfTestMutation) SetReceivedMbps(f float64) {
	m.received_mbps = &f
	m.addreceived_mbps = nil
}

// ReceivedMbps returns the value of the "received_mbps" field in the mutation.
func (m *IperfTestMutation) ReceivedMbps() (r float64, exists bool) {
	v := m.received_mbps
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedMbps returns the old "received_mbps" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldReceivedMbps(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedMbps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedMbps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedMbps: %w", err)
	}
	return oldValue.ReceivedMbps, nil
}

// AddReceivedMbps adds f to the "received_mbps" field.
func (m *IperfTestMutation) AddReceivedMbps(f float64) {
	if m.addreceived_mbps != nil {
		*m.addreceived_mbps += f
	} else {
		m.addreceived_mbps = &f
	}
}

// AddedReceivedMbps returns the value that was added to the "received_mbps" field in this mutation.
func (m *IperfTestMutation) AddedReceivedMbps() (r float64, exists bool) {
	v := m.addreceived_mbps
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceivedMbps resets all changes to the "received_mbps" field.
func (m *IperfTestMutation) ResetReceivedMbps() {
	m.received_mbps = nil
	m.addreceived_mbps = nil
}

// SetRetransmits sets the "retransmits" field.
func (m *IperfTestMutation) SetRetransmits(f float64) {
	m.retransmits = &f
	m.addretransmits = nil
}

// Retransmits returns the value of the "retransmits" field in the mutation.
func (m *IperfTestMutation) Retransmits() (r float64, exists bool) {
	v := m.retransmits
	if v == nil {
		return
	}
	return *v, true
}

// OldRetransmits returns the old "retransmits" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldRetransmits(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetransmits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetransmits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetransmits: %w", err)
	}
	return oldValue.Retransmits, nil
}

// AddRetransmits adds f to the "retransmits" field.
func (m *IperfTestMutation) AddRetransmits(f float64) {
	if m.addretransmits != nil {
		*m.addretransmits += f
	} else {
		m.addretransmits = &f
	}
}

// AddedRetransmits returns the value that was added to the "retransmits" field in this mutation.
func (m *IperfTestMutation) AddedRetransmits() (r float64, exists bool) {
	v := m.addretransmits
	if v == nil {
		return
	}
	return *v, true
}

// ClearRetransmits clears the value of the "retransmits" field.
func (m *IperfTestMutation) ClearRetransmits() {
	m.retransmits = nil
	m.addretransmits = nil
	m.clearedFields[iperftest.FieldRetransmits] = struct{}{}
}

// RetransmitsCleared returns if the "retransmits" field was cleared in this mutation.
func (m *IperfTestMutation) RetransmitsCleared() bool {
	_, ok := m.clearedFields[iperftest.FieldRetransmits]
	return ok
}

// ResetRetransmits resets all changes to the "retransmits" field.
func (m *IperfTestMutation) ResetRetransmits() {
	m.retransmits = nil
	m.addretransmits = nil
	delete(m.clearedFields, iperftest.FieldRetransmits)
}

// SetMeanRttMs sets the "mean_rtt_ms" field.
func (m *IperfTestMutation) SetMeanRttMs(f float64) {
	m.mean_rtt_ms = &f
	m.addmean_rtt_ms = nil
}

// MeanRttMs returns the value of the "mean_rtt_ms" field in the mutation.
func (m *IperfTestMutation) MeanRttMs() (r float64, exists bool) {
	v := m.mean_rtt_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldMeanRttMs returns the old "mean_rtt_ms" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldMeanRttMs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeanRttMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeanRttMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeanRttMs: %w", err)
	}
	return oldValue.MeanRttMs, nil
}

// AddMeanRttMs adds f to the "mean_rtt_ms" field.
func (m *IperfTestMutation) AddMeanRttMs(f float64) {
	if m.addmean_rtt_ms != nil {
		*m.addmean_rtt_ms += f
	} else {
		m.addmean_rtt_ms = &f
	}
}

// AddedMeanRttMs returns the value that was added to the "mean_rtt_ms" field in this mutation.
func (m *IperfTestMutation) AddedMeanRttMs() (r float64, exists bool) {
	v := m.addmean_rtt_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearMeanRttMs clears the value of the "mean_rtt_ms" field.
func (m *IperfTestMutation) ClearMeanRttMs() {
	m.mean_rtt_ms = nil
	m.addmean_rtt_ms = nil
	m.clearedFields[iperftest.FieldMeanRttMs] = struct{}{}
}

// MeanRttMsCleared returns if the "mean_rtt_ms" field was cleared in this mutation.
func (m *IperfTestMutation) MeanRttMsCleared() bool {
	_, ok := m.clearedFields[iperftest.FieldMeanRttMs]
	return ok
}

// ResetMeanRttMs resets all changes to the "mean_rtt_ms" field.
func (m *IperfTestMutation) ResetMeanRttMs() {
	m.mean_rtt_ms = nil
	m.addmean_rtt_ms = nil
	delete(m.clearedFields, iperftest.FieldMeanRttMs)
}

// SetDurationSeconds sets the "duration_seconds" field.
func (m *IperfTestMutation) SetDurationSeconds(i int) {
	m.duration_seconds = &i
	m.addduration_seconds = nil
}

// DurationSeconds returns the value of the "duration_seconds" field in the mutation.
func (m *IperfTestMutation) DurationSeconds() (r int, exists bool) {
	v := m.duration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationSeconds returns the old "duration_seconds" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldDurationSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationSeconds: %w", err)
	}
	return oldValue.DurationSeconds, nil
}

// AddDurationSeconds adds i to the "duration_seconds" field.
func (m *IperfTestMutation) AddDurationSeconds(i int) {
	if m.addduration_seconds != nil {
		*m.addduration_seconds += i
	} else {
		m.addduration_seconds = &i
	}
}

// AddedDurationSeconds returns the value that was added to the "duration_seconds" field in this mutation.
func (m *IperfTestMutation) AddedDurationSeconds() (r int, exists bool) {
	v := m.addduration_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationSeconds resets all changes to the "duration_seconds" field.
func (m *IperfTestMutation) ResetDurationSeconds() {
	m.duration_seconds = nil
	m.addduration_seconds = nil
}

// SetProtocol sets the "protocol" field.
func (m *IperfTestMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *IperfTestMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *IperfTestMutation) ResetProtocol() {
	m.protocol = nil
}

// SetSuccess sets the "success" field.
func (m *IperfTestMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *IperfTestMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *IperfTestMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *IperfTestMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *IperfTestMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *IperfTestMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[iperftest.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *IperfTestMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[iperftest.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *IperfTestMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, iperftest.FieldErrorMessage)
}

// SetDaemonID sets the "daemon_id" field.
func (m *IperfTestMutation) SetDaemonID(s string) {
	m.daemon_id = &s
}

// DaemonID returns the value of the "daemon_id" field in the mutation.
func (m *IperfTestMutation) DaemonID() (r string, exists bool) {
	v := m.daemon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDaemonID returns the old "daemon_id" field's value of the IperfTest entity.
// If the IperfTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IperfTestMutation) OldDaemonID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaemonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaemonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaemonID: %w", err)
	}
	return oldValue.DaemonID, nil
}

// ClearDaemonID clears the value of the "daemon_id" field.
func (m *IperfTestMutation) ClearDaemonID() {
	m.daemon_id = nil
	m.clearedFields[iperftest.FieldDaemonID] = struct{}{}
}

// DaemonIDCleared returns if the "daemon_id" field was cleared in this mutation.
func (m *IperfTestMutation) DaemonIDCleared() bool {
	_, ok := m.clearedFields[iperftest.FieldDaemonID]
	return ok
}

// ResetDaemonID resets all changes to the "daemon_id" field.
func (m *IperfTestMutation) ResetDaemonID() {
	m.daemon_id = nil
	delete(m.clearedFields, iperftest.FieldDaemonID)
}

// SetHostID sets the "host" edge to the Host entity by id.
func (m *IperfTestMutation) SetHostID(id int) {
	m.host = &id
}

// ClearHost clears the "host" edge to the Host entity.
func (m *IperfTestMutation) ClearHost() {
	m.clearedhost = true
}

// HostCleared reports if the "host" edge to the Host entity was cleared.
func (m *IperfTestMutation) HostCleared() bool {
	return m.clearedhost
}

// HostID returns the "host" edge ID in the mutation.
func (m *IperfTestMutation) HostID() (id int, exists bool) {
	if m.host != nil {
		return *m.host, true
	}
	return
}

// HostIDs returns the "host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *IperfTestMutation) HostIDs() (ids []int) {
	if id := m.host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "host" edge.
func (m *IperfTestMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
}

// Where appends a list predicates to the IperfTestMutation builder.
func (m *IperfTestMutation) Where(ps ...predicate.IperfTest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IperfTestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IperfTestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IperfTest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IperfTestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IperfTestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IperfTest).
func (m *IperfTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IperfTestMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.timestamp != nil {
		fields = append(fields, iperftest.FieldTimestamp)
	}
	if m.sent_mbps != nil {
		fields = append(fields, iperftest.FieldSentMbps)
	}
	if m.received_mbps != nil {
		fields = append(fields, iperftest.FieldReceivedMbps)
	}
	if m.retransmits != nil {
		fields = append(fields, iperftest.FieldRetransmits)
	}
	if m.mean_rtt_ms != nil {
		fields = append(fields, iperftest.FieldMeanRttMs)
	}
	if m.duration_seconds != nil {
		fields = append(fields, iperftest.FieldDurationSeconds)
	}
	if m.protocol != nil {
		fields = append(fields, iperftest.FieldProtocol)
	}
	if m.success != nil {
		fields = append(fields, iperftest.FieldSuccess)
	}
	if m.error_message != nil {
		fields = append(fields, iperftest.FieldErrorMessage)
	}
	if m.daemon_id != nil {
		fields = append(fields, iperftest.FieldDaemonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IperfTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case iperftest.FieldTimestamp:
		return m.Timestamp()
	case iperftest.FieldSentMbps:
		return m.SentMbps()
	case iperftest.FieldReceivedMbps:
		return m.ReceivedMbps()
	case iperftest.FieldRetransmits:
		return m.Retransmits()
	case iperftest.FieldMeanRttMs:
		return m.MeanRttMs()
	case iperftest.FieldDurationSeconds:
		return m.DurationSeconds()
	case iperftest.FieldProtocol:
		return m.Protocol()
	case iperftest.FieldSuccess:
		return m.Success()
	case iperftest.FieldErrorMessage:
		return m.ErrorMessage()
	case iperftest.FieldDaemonID:
		return m.DaemonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IperfTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case iperftest.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case iperftest.FieldSentMbps:
		return m.OldSentMbps(ctx)
	case iperftest.FieldReceivedMbps:
		return m.OldReceivedMbps(ctx)
	case iperftest.FieldRetransmits:
		return m.OldRetransmits(ctx)
	case iperftest.FieldMeanRttMs:
		return m.OldMeanRttMs(ctx)
	case iperftest.FieldDurationSeconds:
		return m.OldDurationSeconds(ctx)
	case iperftest.FieldProtocol:
		return m.OldProtocol(ctx)
	case iperftest.FieldSuccess:
		return m.OldSuccess(ctx)
	case iperftest.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case iperftest.FieldDaemonID:
		return m.OldDaemonID(ctx)
	}
	return nil, fmt.Errorf("unknown IperfTest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IperfTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case iperftest.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case iperftest.FieldSentMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentMbps(v)
		return nil
	case iperftest.FieldReceivedMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedMbps(v)
		return nil
	case iperftest.FieldRetransmits:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetransmits(v)
		return nil
	case iperftest.FieldMeanRttMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeanRttMs(v)
		return nil
	case iperftest.FieldDurationSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationSeconds(v)
		return nil
	case iperftest.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case iperftest.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case iperftest.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case iperftest.FieldDaemonID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaemonID(v)
		return nil
	}
	return fmt.Errorf("unknown IperfTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IperfTestMutation) AddedFields() []string {
	var fields []string
	if m.addsent_mbps != nil {
		fields = append(fields, iperftest.FieldSentMbps)
	}
	if m.addreceived_mbps != nil {
		fields = append(fields, iperftest.FieldReceivedMbps)
	}
	if m.addretransmits != nil {
		fields = append(fields, iperftest.FieldRetransmits)
	}
	if m.addmean_rtt_ms != nil {
		fields = append(fields, iperftest.FieldMeanRttMs)
	}
	if m.addduration_seconds != nil {
		fields = append(fields, iperftest.FieldDurationSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IperfTestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case iperftest.FieldSentMbps:
		return m.AddedSentMbps()
	case iperftest.FieldReceivedMbps:
		return m.AddedReceivedMbps()
	case iperftest.FieldRetransmits:
		return m.AddedRetransmits()
	case iperftest.FieldMeanRttMs:
		return m.AddedMeanRttMs()
	case iperftest.FieldDurationSeconds:
		return m.AddedDurationSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IperfTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case iperftest.FieldSentMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentMbps(v)
		return nil
	case iperftest.FieldReceivedMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivedMbps(v)
		return nil
	case iperftest.FieldRetransmits:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetransmits(v)
		return nil
	case iperftest.FieldMeanRttMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMeanRttMs(v)
		return nil
	case iperftest.FieldDurationSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown IperfTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IperfTestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(iperftest.FieldRetransmits) {
		fields = append(fields, iperftest.FieldRetransmits)
	}
	if m.FieldCleared(iperftest.FieldMeanRttMs) {
		fields = append(fields, iperftest.FieldMeanRttMs)
	}
	if m.FieldCleared(iperftest.FieldErrorMessage) {
		fields = append(fields, iperftest.FieldErrorMessage)
	}
	if m.FieldCleared(iperftest.FieldDaemonID) {
		fields = append(fields, iperftest.FieldDaemonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IperfTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IperfTestMutation) ClearField(name string) error {
	switch name {
	case iperftest.FieldRetransmits:
		m.ClearRetransmits()
		return nil
	case iperftest.FieldMeanRttMs:
		m.ClearMeanRttMs()
		return nil
	case iperftest.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case iperftest.FieldDaemonID:
		m.ClearDaemonID()
		return nil
	}
	return fmt.Errorf("unknown IperfTest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IperfTestMutation) ResetField(name string) error {
	switch name {
	case iperftest.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case iperftest.FieldSentMbps:
		m.ResetSentMbps()
		return nil
	case iperftest.FieldReceivedMbps:
		m.ResetReceivedMbps()
		return nil
	case iperftest.FieldRetransmits:
		m.ResetRetransmits()
		return nil
	case iperftest.FieldMeanRttMs:
		m.ResetMeanRttMs()
		return nil
	case iperftest.FieldDurationSeconds:
		m.ResetDurationSeconds()
		return nil
	case iperftest.FieldProtocol:
		m.ResetProtocol()
		return nil
	case iperftest.FieldSuccess:
		m.ResetSuccess()
		return nil
	case iperftest.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case iperftest.FieldDaemonID:
		m.ResetDaemonID()
		return nil
	}
	return fmt.Errorf("unknown IperfTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IperfTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host != nil {
		edges = append(edges, iperftest.EdgeHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IperfTestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case iperftest.EdgeHost:
		if id := m.host; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IperfTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IperfTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IperfTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost {
		edges = append(edges, iperftest.EdgeHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IperfTestMutation) EdgeCleared(name string) bool {
	switch name {
	case iperftest.EdgeHost:
		return m.clearedhost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IperfTestMutation) ClearEdge(name string) error {
	switch name {
	case iperftest.EdgeHost:
		m.ClearHost()
		return nil
	}
	return fmt.Errorf("unknown IperfTest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IperfTestMutation) ResetEdge(name string) error {
	switch name {
	case iperftest.EdgeHost:
		m.ResetHost()
		return nil
	}
	return fmt.Errorf("unknown IperfTest edge %s", name)
}

// SpeedTestMutation represents an operation that mutates the SpeedTest nodes in the graph.
type SpeedTestMutation struct {
	config
	op               Op
	typ              string
	id               *int
	timestamp        *time.Time
	download_mbps    *float64
	adddownload_mbps *float64
	upload_mbps      *float64
	addupload_mbps   *float64
	ping_ms          *float64
	addping_ms       *float64
	jitter_ms        *float64
	addjitter_ms     *float64
	server_name      *string
	server_id        *string
	isp              *string
	external_ip      *string
	result_url       *string
	daemon_id        *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*SpeedTest, error)
	predicates       []predicate.SpeedTest
}

var _ ent.Mutation = (*SpeedTestMutation)(nil)

// speedtestOption allows management of the mutation configuration using functional options.
type speedtestOption func(*SpeedTestMutation)

// newSpeedTestMutation creates new mutation for the SpeedTest entity.
func newSpeedTestMutation(c config, op Op, opts ...speedtestOption) *SpeedTestMutation {
	m := &SpeedTestMutation{
		config:        c,
		op:            op,
		typ:           TypeSpeedTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpeedTestID sets the ID field of the mutation.
func withSpeedTestID(id int) speedtestOption {
	return func(m *SpeedTestMutation) {
		var (
			err   error
			once  sync.Once
			value *SpeedTest
		)
		m.oldValue = func(ctx context.Context) (*SpeedTest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpeedTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpeedTest sets the old SpeedTest of the mutation.
func withSpeedTest(node *SpeedTest) speedtestOption {
	return func(m *SpeedTestMutation) {
		m.oldValue = func(context.Context) (*SpeedTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpeedTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpeedTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpeedTestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpeedTestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SpeedTest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *SpeedTestMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SpeedTestMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SpeedTestMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetDownloadMbps sets the "download_mbps" field.
func (m *SpeedTestMutation) SetDownloadMbps(f float64) {
	m.download_mbps = &f
	m.adddownload_mbps = nil
}

// DownloadMbps returns the value of the "download_mbps" field in the mutation.
func (m *SpeedTestMutation) DownloadMbps() (r float64, exists bool) {
	v := m.download_mbps
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadMbps returns the old "download_mbps" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldDownloadMbps(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadMbps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadMbps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadMbps: %w", err)
	}
	return oldValue.DownloadMbps, nil
}

// AddDownloadMbps adds f to the "download_mbps" field.
func (m *SpeedTestMutation) AddDownloadMbps(f float64) {
	if m.adddownload_mbps != nil {
		*m.adddownload_mbps += f
	} else {
		m.adddownload_mbps = &f
	}
}

// AddedDownloadMbps returns the value that was added to the "download_mbps" field in this mutation.
func (m *SpeedTestMutation) AddedDownloadMbps() (r float64, exists bool) {
	v := m.adddownload_mbps
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloadMbps resets all changes to the "download_mbps" field.
func (m *SpeedTestMutation) ResetDownloadMbps() {
	m.download_mbps = nil
	m.adddownload_mbps = nil
}

// SetUploadMbps sets the "upload_mbps" field.
func (m *SpeedTestMutation) SetUploadMbps(f float64) {
	m.upload_mbps = &f
	m.addupload_mbps = nil
}

// UploadMbps returns the value of the "upload_mbps" field in the mutation.
func (m *SpeedTestMutation) UploadMbps() (r float64, exists bool) {
	v := m.upload_mbps
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadMbps returns the old "upload_mbps" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldUploadMbps(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadMbps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadMbps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadMbps: %w", err)
	}
	return oldValue.UploadMbps, nil
}

// AddUploadMbps adds f to the "upload_mbps" field.
func (m *SpeedTestMutation) AddUploadMbps(f float64) {
	if m.addupload_mbps != nil {
		*m.addupload_mbps += f
	} else {
		m.addupload_mbps = &f
	}
}

// AddedUploadMbps returns the value that was added to the "upload_mbps" field in this mutation.
func (m *SpeedTestMutation) AddedUploadMbps() (r float64, exists bool) {
	v := m.addupload_mbps
	if v == nil {
		return
	}
	return *v, true
}

// ResetUploadMbps resets all changes to the "upload_mbps" field.
func (m *SpeedTestMutation) ResetUploadMbps() {
	m.upload_mbps = nil
	m.addupload_mbps = nil
}

// SetPingMs sets the "ping_ms" field.
func (m *SpeedTestMutation) SetPingMs(f float64) {
	m.ping_ms = &f
	m.addping_ms = nil
}

// PingMs returns the value of the "ping_ms" field in the mutation.
func (m *SpeedTestMutation) PingMs() (r float64, exists bool) {
	v := m.ping_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldPingMs returns the old "ping_ms" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldPingMs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPingMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPingMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPingMs: %w", err)
	}
	return oldValue.PingMs, nil
}

// AddPingMs adds f to the "ping_ms" field.
func (m *SpeedTestMutation) AddPingMs(f float64) {
	if m.addping_ms != nil {
		*m.addping_ms += f
	} else {
		m.addping_ms = &f
	}
}

// AddedPingMs returns the value that was added to the "ping_ms" field in this mutation.
func (m *SpeedTestMutation) AddedPingMs() (r float64, exists bool) {
	v := m.addping_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetPingMs resets all changes to the "ping_ms" field.
func (m *SpeedTestMutation) ResetPingMs() {
	m.ping_ms = nil
	m.addping_ms = nil
}

// SetJitterMs sets the "jitter_ms" field.
func (m *SpeedTestMutation) SetJitterMs(f float64) {
	m.jitter_ms = &f
	m.addjitter_ms = nil
}

// JitterMs returns the value of the "jitter_ms" field in the mutation.
func (m *SpeedTestMutation) JitterMs() (r float64, exists bool) {
	v := m.jitter_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldJitterMs returns the old "jitter_ms" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldJitterMs(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJitterMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJitterMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJitterMs: %w", err)
	}
	return oldValue.JitterMs, nil
}

// AddJitterMs adds f to the "jitter_ms" field.
func (m *SpeedTestMutation) AddJitterMs(f float64) {
	if m.addjitter_ms != nil {
		*m.addjitter_ms += f
	} else {
		m.addjitter_ms = &f
	}
}

// AddedJitterMs returns the value that was added to the "jitter_ms" field in this mutation.
func (m *SpeedTestMutation) AddedJitterMs() (r float64, exists bool) {
	v := m.addjitter_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearJitterMs clears the value of the "jitter_ms" field.
func (m *SpeedTestMutation) ClearJitterMs() {
	m.jitter_ms = nil
	m.addjitter_ms = nil
	m.clearedFields[speedtest.FieldJitterMs] = struct{}{}
}

// JitterMsCleared returns if the "jitter_ms" field was cleared in this mutation.
func (m *SpeedTestMutation) JitterMsCleared() bool {
	_, ok := m.clearedFields[speedtest.FieldJitterMs]
	return ok
}

// ResetJitterMs resets all changes to the "jitter_ms" field.
func (m *SpeedTestMutation) ResetJitterMs() {
	m.jitter_ms = nil
	m.addjitter_ms = nil
	delete(m.clearedFields, speedtest.FieldJitterMs)
}

// SetServerName sets the "server_name" field.
func (m *SpeedTestMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *SpeedTestMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ClearServerName clears the value of the "server_name" field.
func (m *SpeedTestMutation) ClearServerName() {
	m.server_name = nil
	m.clearedFields[speedtest.FieldServerName] = struct{}{}
}

// ServerNameCleared returns if the "server_name" field was cleared in this mutation.
func (m *SpeedTestMutation) ServerNameCleared() bool {
	_, ok := m.clearedFields[speedtest.FieldServerName]
	return ok
}

// ResetServerName resets all changes to the "server_name" field.
func (m *SpeedTestMutation) ResetServerName() {
	m.server_name = nil
	delete(m.clearedFields, speedtest.FieldServerName)
}

// SetServerID sets the "server_id" field.
func (m *SpeedTestMutation) SetServerID(s string) {
	m.server_id = &s
}

// ServerID returns the value of the "server_id" field in the mutation.
func (m *SpeedTestMutation) ServerID() (r string, exists bool) {
	v := m.server_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServerID returns the old "server_id" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldServerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerID: %w", err)
	}
	return oldValue.ServerID, nil
}

// ClearServerID clears the value of the "server_id" field.
func (m *SpeedTestMutation) ClearServerID() {
	m.server_id = nil
	m.clearedFields[speedtest.FieldServerID] = struct{}{}
}

// ServerIDCleared returns if the "server_id" field was cleared in this mutation.
func (m *SpeedTestMutation) ServerIDCleared() bool {
	_, ok := m.clearedFields[speedtest.FieldServerID]
	return ok
}

// ResetServerID resets all changes to the "server_id" field.
func (m *SpeedTestMutation) ResetServerID() {
	m.server_id = nil
	delete(m.clearedFields, speedtest.FieldServerID)
}

// SetIsp sets the "isp" field.
func (m *SpeedTestMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *SpeedTestMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *SpeedTestMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[speedtest.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *SpeedTestMutation) IspCleared() bool {
	_, ok := m.clearedFields[speedtest.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *SpeedTestMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, speedtest.FieldIsp)
}

// SetExternalIP sets the "external_ip" field.
func (m *SpeedTestMutation) SetExternalIP(s string) {
	m.external_ip = &s
}

// ExternalIP returns the value of the "external_ip" field in the mutation.
func (m *SpeedTestMutation) ExternalIP() (r string, exists bool) {
	v := m.external_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalIP returns the old "external_ip" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldExternalIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalIP: %w", err)
	}
	return oldValue.ExternalIP, nil
}

// ClearExternalIP clears the value of the "external_ip" field.
func (m *SpeedTestMutation) ClearExternalIP() {
	m.external_ip = nil
	m.clearedFields[speedtest.FieldExternalIP] = struct{}{}
}

// ExternalIPCleared returns if the "external_ip" field was cleared in this mutation.
func (m *SpeedTestMutation) ExternalIPCleared() bool {
	_, ok := m.clearedFields[speedtest.FieldExternalIP]
	return ok
}

// ResetExternalIP resets all changes to the "external_ip" field.
func (m *SpeedTestMutation) ResetExternalIP() {
	m.external_ip = nil
	delete(m.clearedFields, speedtest.FieldExternalIP)
}

// SetResultURL sets the "result_url" field.
func (m *SpeedTestMutation) SetResultURL(s string) {
	m.result_url = &s
}

// ResultURL returns the value of the "result_url" field in the mutation.
func (m *SpeedTestMutation) ResultURL() (r string, exists bool) {
	v := m.result_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResultURL returns the old "result_url" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldResultURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultURL: %w", err)
	}
	return oldValue.ResultURL, nil
}

// ClearResultURL clears the value of the "result_url" field.
func (m *SpeedTestMutation) ClearResultURL() {
	m.result_url = nil
	m.clearedFields[speedtest.FieldResultURL] = struct{}{}
}

// ResultURLCleared returns if the "result_url" field was cleared in this mutation.
func (m *SpeedTestMutation) ResultURLCleared() bool {
	_, ok := m.clearedFields[speedtest.FieldResultURL]
	return ok
}

// ResetResultURL resets all changes to the "result_url" field.
func (m *SpeedTestMutation) ResetResultURL() {
	m.result_url = nil
	delete(m.clearedFields, speedtest.FieldResultURL)
}

// SetDaemonID sets the "daemon_id" field.
func (m *SpeedTestMutation) SetDaemonID(s string) {
	m.daemon_id = &s
}

// DaemonID returns the value of the "daemon_id" field in the mutation.
func (m *SpeedTestMutation) DaemonID() (r string, exists bool) {
	v := m.daemon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDaemonID returns the old "daemon_id" field's value of the SpeedTest entity.
// If the SpeedTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeedTestMutation) OldDaemonID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaemonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaemonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaemonID: %w", err)
	}
	return oldValue.DaemonID, nil
}

// ClearDaemonID clears the value of the "daemon_id" field.
func (m *SpeedTestMutation) ClearDaemonID() {
	m.daemon_id = nil
	m.clearedFields[speedtest.FieldDaemonID] = struct{}{}
}

// DaemonIDCleared returns if the "daemon_id" field was cleared in this mutation.
func (m *SpeedTestMutation) DaemonIDCleared() bool {
	_, ok := m.clearedFields[speedtest.FieldDaemonID]
	return ok
}

// ResetDaemonID resets all changes to the "daemon_id" field.
func (m *SpeedTestMutation) ResetDaemonID() {
	m.daemon_id = nil
	delete(m.clearedFields, speedtest.FieldDaemonID)
}

// Where appends a list predicates to the SpeedTestMutation builder.
func (m *SpeedTestMutation) Where(ps ...predicate.SpeedTest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpeedTestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpeedTestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SpeedTest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpeedTestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpeedTestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SpeedTest).
func (m *SpeedTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpeedTestMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.timestamp != nil {
		fields = append(fields, speedtest.FieldTimestamp)
	}
	if m.download_mbps != nil {
		fields = append(fields, speedtest.FieldDownloadMbps)
	}
	if m.upload_mbps != nil {
		fields = append(fields, speedtest.FieldUploadMbps)
	}
	if m.ping_ms != nil {
		fields = append(fields, speedtest.FieldPingMs)
	}
	if m.jitter_ms != nil {
		fields = append(fields, speedtest.FieldJitterMs)
	}
	if m.server_name != nil {
		fields = append(fields, speedtest.FieldServerName)
	}
	if m.server_id != nil {
		fields = append(fields, speedtest.FieldServerID)
	}
	if m.isp != nil {
		fields = append(fields, speedtest.FieldIsp)
	}
	if m.external_ip != nil {
		fields = append(fields, speedtest.FieldExternalIP)
	}
	if m.result_url != nil {
		fields = append(fields, speedtest.FieldResultURL)
	}
	if m.daemon_id != nil {
		fields = append(fields, speedtest.FieldDaemonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpeedTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case speedtest.FieldTimestamp:
		return m.Timestamp()
	case speedtest.FieldDownloadMbps:
		return m.DownloadMbps()
	case speedtest.FieldUploadMbps:
		return m.UploadMbps()
	case speedtest.FieldPingMs:
		return m.PingMs()
	case speedtest.FieldJitterMs:
		return m.JitterMs()
	case speedtest.FieldServerName:
		return m.ServerName()
	case speedtest.FieldServerID:
		return m.ServerID()
	case speedtest.FieldIsp:
		return m.Isp()
	case speedtest.FieldExternalIP:
		return m.ExternalIP()
	case speedtest.FieldResultURL:
		return m.ResultURL()
	case speedtest.FieldDaemonID:
		return m.DaemonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpeedTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case speedtest.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case speedtest.FieldDownloadMbps:
		return m.OldDownloadMbps(ctx)
	case speedtest.FieldUploadMbps:
		return m.OldUploadMbps(ctx)
	case speedtest.FieldPingMs:
		return m.OldPingMs(ctx)
	case speedtest.FieldJitterMs:
		return m.OldJitterMs(ctx)
	case speedtest.FieldServerName:
		return m.OldServerName(ctx)
	case speedtest.FieldServerID:
		return m.OldServerID(ctx)
	case speedtest.FieldIsp:
		return m.OldIsp(ctx)
	case speedtest.FieldExternalIP:
		return m.OldExternalIP(ctx)
	case speedtest.FieldResultURL:
		return m.OldResultURL(ctx)
	case speedtest.FieldDaemonID:
		return m.OldDaemonID(ctx)
	}
	return nil, fmt.Errorf("unknown SpeedTest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpeedTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case speedtest.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case speedtest.FieldDownloadMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadMbps(v)
		return nil
	case speedtest.FieldUploadMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadMbps(v)
		return nil
	case speedtest.FieldPingMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPingMs(v)
		return nil
	case speedtest.FieldJitterMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJitterMs(v)
		return nil
	case speedtest.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case speedtest.FieldServerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerID(v)
		return nil
	case speedtest.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	case speedtest.FieldExternalIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalIP(v)
		return nil
	case speedtest.FieldResultURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultURL(v)
		return nil
	case speedtest.FieldDaemonID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaemonID(v)
		return nil
	}
	return fmt.Errorf("unknown SpeedTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpeedTestMutation) AddedFields() []string {
	var fields []string
	if m.adddownload_mbps != nil {
		fields = append(fields, speedtest.FieldDownloadMbps)
	}
	if m.addupload_mbps != nil {
		fields = append(fields, speedtest.FieldUploadMbps)
	}
	if m.addping_ms != nil {
		fields = append(fields, speedtest.FieldPingMs)
	}
	if m.addjitter_ms != nil {
		fields = append(fields, speedtest.FieldJitterMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpeedTestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case speedtest.FieldDownloadMbps:
		return m.AddedDownloadMbps()
	case speedtest.FieldUploadMbps:
		return m.AddedUploadMbps()
	case speedtest.FieldPingMs:
		return m.AddedPingMs()
	case speedtest.FieldJitterMs:
		return m.AddedJitterMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpeedTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case speedtest.FieldDownloadMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadMbps(v)
		return nil
	case speedtest.FieldUploadMbps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploadMbps(v)
		return nil
	case speedtest.FieldPingMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPingMs(v)
		return nil
	case speedtest.FieldJitterMs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJitterMs(v)
		return nil
	}
	return fmt.Errorf("unknown SpeedTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpeedTestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(speedtest.FieldJitterMs) {
		fields = append(fields, speedtest.FieldJitterMs)
	}
	if m.FieldCleared(speedtest.FieldServerName) {
		fields = append(fields, speedtest.FieldServerName)
	}
	if m.FieldCleared(speedtest.FieldServerID) {
		fields = append(fields, speedtest.FieldServerID)
	}
	if m.FieldCleared(speedtest.FieldIsp) {
		fields = append(fields, speedtest.FieldIsp)
	}
	if m.FieldCleared(speedtest.FieldExternalIP) {
		fields = append(fields, speedtest.FieldExternalIP)
	}
	if m.FieldCleared(speedtest.FieldResultURL) {
		fields = append(fields, speedtest.FieldResultURL)
	}
	if m.FieldCleared(speedtest.FieldDaemonID) {
		fields = append(fields, speedtest.FieldDaemonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpeedTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpeedTestMutation) ClearField(name string) error {
	switch name {
	case speedtest.FieldJitterMs:
		m.ClearJitterMs()
		return nil
	case speedtest.FieldServerName:
		m.ClearServerName()
		return nil
	case speedtest.FieldServerID:
		m.ClearServerID()
		return nil
	case speedtest.FieldIsp:
		m.ClearIsp()
		return nil
	case speedtest.FieldExternalIP:
		m.ClearExternalIP()
		return nil
	case speedtest.FieldResultURL:
		m.ClearResultURL()
		return nil
	case speedtest.FieldDaemonID:
		m.ClearDaemonID()
		return nil
	}
	return fmt.Errorf("unknown SpeedTest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpeedTestMutation) ResetField(name string) error {
	switch name {
	case speedtest.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case speedtest.FieldDownloadMbps:
		m.ResetDownloadMbps()
		return nil
	case speedtest.FieldUploadMbps:
		m.ResetUploadMbps()
		return nil
	case speedtest.FieldPingMs:
		m.ResetPingMs()
		return nil
	case speedtest.FieldJitterMs:
		m.ResetJitterMs()
		return nil
	case speedtest.FieldServerName:
		m.ResetServerName()
		return nil
	case speedtest.FieldServerID:
		m.ResetServerID()
		return nil
	case speedtest.FieldIsp:
		m.ResetIsp()
		return nil
	case speedtest.FieldExternalIP:
		m.ResetExternalIP()
		return nil
	case speedtest.FieldResultURL:
		m.ResetResultURL()
		return nil
	case speedtest.FieldDaemonID:
		m.ResetDaemonID()
		return nil
	}
	return fmt.Errorf("unknown SpeedTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpeedTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpeedTestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpeedTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpeedTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpeedTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpeedTestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpeedTestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SpeedTest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpeedTestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SpeedTest edge %s", name)
}

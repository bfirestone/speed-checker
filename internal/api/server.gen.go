// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for HostType.
const (
	Lan    HostType = "lan"
	Remote HostType = "remote"
	Vpn    HostType = "vpn"
)

// Defines values for IperfTestResultProtocol.
const (
	IperfTestResultProtocolTCP IperfTestResultProtocol = "TCP"
	IperfTestResultProtocolUDP IperfTestResultProtocol = "UDP"
)

// Defines values for IperfTestSubmissionProtocol.
const (
	IperfTestSubmissionProtocolTCP IperfTestSubmissionProtocol = "TCP"
	IperfTestSubmissionProtocolUDP IperfTestSubmissionProtocol = "UDP"
)

// DashboardData defines model for DashboardData.
type DashboardData struct {
	// ActiveHosts List of active hosts available for testing
	ActiveHosts []Host `json:"active_hosts"`

	// RecentIperfTests Recent iperf test results
	RecentIperfTests []IperfTestResult `json:"recent_iperf_tests"`

	// RecentSpeedTests Recent speed test results
	RecentSpeedTests []SpeedTestResult `json:"recent_speed_tests"`
	Statistics       struct {
		// ActiveHosts Number of active hosts
		ActiveHosts *int `json:"active_hosts,omitempty"`

		// AvgDownloadMbps Average download speed over last 24h
		AvgDownloadMbps *float64 `json:"avg_download_mbps,omitempty"`

		// AvgUploadMbps Average upload speed over last 24h
		AvgUploadMbps *float64 `json:"avg_upload_mbps,omitempty"`

		// TotalIperfTests Total number of iperf tests
		TotalIperfTests *int `json:"total_iperf_tests,omitempty"`

		// TotalSpeedTests Total number of speed tests
		TotalSpeedTests *int `json:"total_speed_tests,omitempty"`
	} `json:"statistics"`
}

// Error defines model for Error.
type Error struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error code or type
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// Host defines model for Host.
type Host struct {
	// Active Whether the host is active for testing
	Active *bool `json:"active,omitempty"`

	// CreatedAt When the host was created
	CreatedAt time.Time `json:"created_at"`

	// Description Optional description of the host
	Description *string `json:"description,omitempty"`

	// Hostname Hostname or IP address
	Hostname string `json:"hostname"`

	// Id Unique identifier for the host
	Id int `json:"id"`

	// Name Human-readable name for the host
	Name string `json:"name"`

	// Port Port number for iperf3 server
	Port int `json:"port"`

	// Type Type of host for categorizing network tests
	Type HostType `json:"type"`

	// UpdatedAt When the host was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// HostCreation defines model for HostCreation.
type HostCreation struct {
	// Active Whether the host is active for testing
	Active *bool `json:"active,omitempty"`

	// Description Optional description of the host
	Description *string `json:"description,omitempty"`

	// Hostname Hostname or IP address
	Hostname string `json:"hostname"`

	// Name Human-readable name for the host
	Name string `json:"name"`

	// Port Port number for iperf3 server
	Port int `json:"port"`

	// Type Type of host for categorizing network tests
	Type HostType `json:"type"`
}

// HostType Type of host for categorizing network tests
type HostType string

// HostUpdate defines model for HostUpdate.
type HostUpdate struct {
	// Active Whether the host is active for testing
	Active *bool `json:"active,omitempty"`

	// Description Optional description of the host
	Description *string `json:"description,omitempty"`

	// Hostname Hostname or IP address
	Hostname string `json:"hostname"`

	// Name Human-readable name for the host
	Name string `json:"name"`

	// Port Port number for iperf3 server
	Port int `json:"port"`

	// Type Type of host for categorizing network tests
	Type HostType `json:"type"`
}

// IperfTestResult defines model for IperfTestResult.
type IperfTestResult struct {
	// CreatedAt When the result was stored in the system
	CreatedAt time.Time `json:"created_at"`

	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DurationSeconds Test duration in seconds
	DurationSeconds int `json:"duration_seconds"`

	// ErrorMessage Error message if test failed
	ErrorMessage *string `json:"error_message,omitempty"`
	Host         Host    `json:"host"`

	// HostId ID of the target host
	HostId int `json:"host_id"`

	// Id Unique identifier for the test result
	Id int `json:"id"`

	// MeanRttMs Mean round-trip time in milliseconds
	MeanRttMs *float64 `json:"mean_rtt_ms,omitempty"`

	// Protocol Protocol used for the test
	Protocol IperfTestResultProtocol `json:"protocol"`

	// ReceivedMbps Received throughput in Mbps
	ReceivedMbps float64 `json:"received_mbps"`

	// Retransmits Number of retransmitted packets
	Retransmits *float64 `json:"retransmits,omitempty"`

	// SentMbps Sent throughput in Mbps
	SentMbps float64 `json:"sent_mbps"`

	// Success Whether the test was successful
	Success *bool `json:"success,omitempty"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`
}

// IperfTestResultProtocol Protocol used for the test
type IperfTestResultProtocol string

// IperfTestSubmission defines model for IperfTestSubmission.
type IperfTestSubmission struct {
	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DurationSeconds Test duration in seconds
	DurationSeconds int `json:"duration_seconds"`

	// HostId ID of the target host
	HostId int `json:"host_id"`

	// MeanRttMs Mean round-trip time in milliseconds
	MeanRttMs *float64 `json:"mean_rtt_ms,omitempty"`

	// Protocol Protocol used for the test
	Protocol IperfTestSubmissionProtocol `json:"protocol"`

	// ReceivedMbps Received throughput in Mbps
	ReceivedMbps float64 `json:"received_mbps"`

	// Retransmits Number of retransmitted packets
	Retransmits *float64 `json:"retransmits,omitempty"`

	// SentMbps Sent throughput in Mbps
	SentMbps float64 `json:"sent_mbps"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`
}

// IperfTestSubmissionProtocol Protocol used for the test
type IperfTestSubmissionProtocol string

// SpeedTestResult defines model for SpeedTestResult.
type SpeedTestResult struct {
	// CreatedAt When the result was stored in the system
	CreatedAt time.Time `json:"created_at"`

	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DownloadMbps Download speed in Mbps
	DownloadMbps float64 `json:"download_mbps"`

	// ExternalIp External IP address used for the test
	ExternalIp *string `json:"external_ip,omitempty"`

	// Id Unique identifier for the test result
	Id int `json:"id"`

	// Isp Internet Service Provider
	Isp *string `json:"isp,omitempty"`

	// JitterMs Jitter in milliseconds
	JitterMs *float64 `json:"jitter_ms,omitempty"`

	// PingMs Ping latency in milliseconds
	PingMs float64 `json:"ping_ms"`

	// ResultUrl URL to full test results
	ResultUrl *string `json:"result_url,omitempty"`

	// ServerId Speed test server ID
	ServerId *string `json:"server_id,omitempty"`

	// ServerName Speed test server name
	ServerName *string `json:"server_name,omitempty"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`

	// UploadMbps Upload speed in Mbps
	UploadMbps float64 `json:"upload_mbps"`
}

// SpeedTestSubmission defines model for SpeedTestSubmission.
type SpeedTestSubmission struct {
	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DownloadMbps Download speed in Mbps
	DownloadMbps float64 `json:"download_mbps"`

	// ExternalIp External IP address used for the test
	ExternalIp *string `json:"external_ip,omitempty"`

	// Isp Internet Service Provider
	Isp *string `json:"isp,omitempty"`

	// JitterMs Jitter in milliseconds
	JitterMs *float64 `json:"jitter_ms,omitempty"`

	// PingMs Ping latency in milliseconds
	PingMs float64 `json:"ping_ms"`

	// ResultUrl URL to full test results
	ResultUrl *string `json:"result_url,omitempty"`

	// ServerId Speed test server ID
	ServerId *string `json:"server_id,omitempty"`

	// ServerName Speed test server name
	ServerName *string `json:"server_name,omitempty"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`

	// UploadMbps Upload speed in Mbps
	UploadMbps float64 `json:"upload_mbps"`
}

// GetHostsParams defines parameters for GetHosts.
type GetHostsParams struct {
	// Type Filter by host type
	Type *HostType `form:"type,omitempty" json:"type,omitempty"`

	// Active Filter by active status
	Active *bool `form:"active,omitempty" json:"active,omitempty"`
}

// GetIperfTestsParams defines parameters for GetIperfTests.
type GetIperfTestsParams struct {
	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of results to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// StartTime Filter results after this timestamp (RFC3339)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime Filter results before this timestamp (RFC3339)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// HostId Filter by host ID
	HostId *int `form:"host_id,omitempty" json:"host_id,omitempty"`

	// DaemonId Filter by daemon ID
	DaemonId *string `form:"daemon_id,omitempty" json:"daemon_id,omitempty"`
}

// GetSpeedTestsParams defines parameters for GetSpeedTests.
type GetSpeedTestsParams struct {
	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of results to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// StartTime Filter results after this timestamp (RFC3339)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime Filter results before this timestamp (RFC3339)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// DaemonId Filter by daemon ID
	DaemonId *string `form:"daemon_id,omitempty" json:"daemon_id,omitempty"`
}

// AddHostJSONRequestBody defines body for AddHost for application/json ContentType.
type AddHostJSONRequestBody = HostCreation

// UpdateHostJSONRequestBody defines body for UpdateHost for application/json ContentType.
type UpdateHostJSONRequestBody = HostUpdate

// SubmitIperfTestJSONRequestBody defines body for SubmitIperfTest for application/json ContentType.
type SubmitIperfTestJSONRequestBody = IperfTestSubmission

// SubmitSpeedTestJSONRequestBody defines body for SubmitSpeedTest for application/json ContentType.
type SubmitSpeedTestJSONRequestBody = SpeedTestSubmission

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get dashboard data
	// (GET /dashboard)
	GetDashboard(ctx echo.Context) error
	// Get iperf test hosts
	// (GET /hosts)
	GetHosts(ctx echo.Context, params GetHostsParams) error
	// Add new host
	// (POST /hosts)
	AddHost(ctx echo.Context) error
	// Delete host
	// (DELETE /hosts/{hostId})
	DeleteHost(ctx echo.Context, hostId int) error
	// Get host by ID
	// (GET /hosts/{hostId})
	GetHost(ctx echo.Context, hostId int) error
	// Update host
	// (PUT /hosts/{hostId})
	UpdateHost(ctx echo.Context, hostId int) error
	// Get iperf test results
	// (GET /iperf/results)
	GetIperfTests(ctx echo.Context, params GetIperfTestsParams) error
	// Submit iperf test results
	// (POST /iperf/results)
	SubmitIperfTest(ctx echo.Context) error
	// Delete iperf test result
	// (DELETE /iperf/results/{testId})
	DeleteIperfTest(ctx echo.Context, testId int) error
	// Get speed test results
	// (GET /speedtest/results)
	GetSpeedTests(ctx echo.Context, params GetSpeedTestsParams) error
	// Submit speed test results
	// (POST /speedtest/results)
	SubmitSpeedTest(ctx echo.Context) error
	// Delete speed test result
	// (DELETE /speedtest/results/{testId})
	DeleteSpeedTest(ctx echo.Context, testId int) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetDashboard converts echo context to params.
func (w *ServerInterfaceWrapper) GetDashboard(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDashboard(ctx)
	return err
}

// GetHosts converts echo context to params.
func (w *ServerInterfaceWrapper) GetHosts(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetHostsParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHosts(ctx, params)
	return err
}

// AddHost converts echo context to params.
func (w *ServerInterfaceWrapper) AddHost(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddHost(ctx)
	return err
}

// DeleteHost converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteHost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hostId" -------------
	var hostId int

	err = runtime.BindStyledParameterWithOptions("simple", "hostId", ctx.Param("hostId"), &hostId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hostId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteHost(ctx, hostId)
	return err
}

// GetHost converts echo context to params.
func (w *ServerInterfaceWrapper) GetHost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hostId" -------------
	var hostId int

	err = runtime.BindStyledParameterWithOptions("simple", "hostId", ctx.Param("hostId"), &hostId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hostId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHost(ctx, hostId)
	return err
}

// UpdateHost converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateHost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hostId" -------------
	var hostId int

	err = runtime.BindStyledParameterWithOptions("simple", "hostId", ctx.Param("hostId"), &hostId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hostId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateHost(ctx, hostId)
	return err
}

// GetIperfTests converts echo context to params.
func (w *ServerInterfaceWrapper) GetIperfTests(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIperfTestsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "host_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "host_id", ctx.QueryParams(), &params.HostId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host_id: %s", err))
	}

	// ------------- Optional query parameter "daemon_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "daemon_id", ctx.QueryParams(), &params.DaemonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daemon_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIperfTests(ctx, params)
	return err
}

// SubmitIperfTest converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitIperfTest(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitIperfTest(ctx)
	return err
}

// DeleteIperfTest converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteIperfTest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "testId" -------------
	var testId int

	err = runtime.BindStyledParameterWithOptions("simple", "testId", ctx.Param("testId"), &testId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter testId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteIperfTest(ctx, testId)
	return err
}

// GetSpeedTests converts echo context to params.
func (w *ServerInterfaceWrapper) GetSpeedTests(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSpeedTestsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "daemon_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "daemon_id", ctx.QueryParams(), &params.DaemonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daemon_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSpeedTests(ctx, params)
	return err
}

// SubmitSpeedTest converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitSpeedTest(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitSpeedTest(ctx)
	return err
}

// DeleteSpeedTest converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSpeedTest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "testId" -------------
	var testId int

	err = runtime.BindStyledParameterWithOptions("simple", "testId", ctx.Param("testId"), &testId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter testId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSpeedTest(ctx, testId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/dashboard", wrapper.GetDashboard)
	router.GET(baseURL+"/hosts", wrapper.GetHosts)
	router.POST(baseURL+"/hosts", wrapper.AddHost)
	router.DELETE(baseURL+"/hosts/:hostId", wrapper.DeleteHost)
	router.GET(baseURL+"/hosts/:hostId", wrapper.GetHost)
	router.PUT(baseURL+"/hosts/:hostId", wrapper.UpdateHost)
	router.GET(baseURL+"/iperf/results", wrapper.GetIperfTests)
	router.POST(baseURL+"/iperf/results", wrapper.SubmitIperfTest)
	router.DELETE(baseURL+"/iperf/results/:testId", wrapper.DeleteIperfTest)
	router.GET(baseURL+"/speedtest/results", wrapper.GetSpeedTests)
	router.POST(baseURL+"/speedtest/results", wrapper.SubmitSpeedTest)
	router.DELETE(baseURL+"/speedtest/results/:testId", wrapper.DeleteSpeedTest)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"PQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

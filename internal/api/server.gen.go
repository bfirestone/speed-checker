// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for HostType.
const (
	Lan    HostType = "lan"
	Remote HostType = "remote"
	Vpn    HostType = "vpn"
)

// Defines values for IperfTestResultProtocol.
const (
	IperfTestResultProtocolTCP IperfTestResultProtocol = "TCP"
	IperfTestResultProtocolUDP IperfTestResultProtocol = "UDP"
)

// Defines values for IperfTestSubmissionProtocol.
const (
	IperfTestSubmissionProtocolTCP IperfTestSubmissionProtocol = "TCP"
	IperfTestSubmissionProtocolUDP IperfTestSubmissionProtocol = "UDP"
)

// DashboardData defines model for DashboardData.
type DashboardData struct {
	// ActiveHosts List of active hosts available for testing
	ActiveHosts []Host `json:"active_hosts"`

	// RecentIperfTests Recent iperf test results
	RecentIperfTests []IperfTestResult `json:"recent_iperf_tests"`

	// RecentSpeedTests Recent speed test results
	RecentSpeedTests []SpeedTestResult `json:"recent_speed_tests"`
	Statistics       struct {
		// ActiveHosts Number of active hosts
		ActiveHosts *int `json:"active_hosts,omitempty"`

		// AvgDownloadMbps Average download speed over last 24h
		AvgDownloadMbps *float64 `json:"avg_download_mbps,omitempty"`

		// AvgUploadMbps Average upload speed over last 24h
		AvgUploadMbps *float64 `json:"avg_upload_mbps,omitempty"`

		// TotalIperfTests Total number of iperf tests
		TotalIperfTests *int `json:"total_iperf_tests,omitempty"`

		// TotalSpeedTests Total number of speed tests
		TotalSpeedTests *int `json:"total_speed_tests,omitempty"`
	} `json:"statistics"`
}

// Error defines model for Error.
type Error struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error code or type
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// Host defines model for Host.
type Host struct {
	// Active Whether the host is active for testing
	Active *bool `json:"active,omitempty"`

	// CreatedAt When the host was created
	CreatedAt time.Time `json:"created_at"`

	// Description Optional description of the host
	Description *string `json:"description,omitempty"`

	// Hostname Hostname or IP address
	Hostname string `json:"hostname"`

	// Id Unique identifier for the host
	Id int `json:"id"`

	// Name Human-readable name for the host
	Name string `json:"name"`

	// Port Port number for iperf3 server
	Port int `json:"port"`

	// Type Type of host for categorizing network tests
	Type HostType `json:"type"`

	// UpdatedAt When the host was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// HostCreation defines model for HostCreation.
type HostCreation struct {
	// Active Whether the host is active for testing
	Active *bool `json:"active,omitempty"`

	// Description Optional description of the host
	Description *string `json:"description,omitempty"`

	// Hostname Hostname or IP address
	Hostname string `json:"hostname"`

	// Name Human-readable name for the host
	Name string `json:"name"`

	// Port Port number for iperf3 server
	Port int `json:"port"`

	// Type Type of host for categorizing network tests
	Type HostType `json:"type"`
}

// HostType Type of host for categorizing network tests
type HostType string

// HostUpdate defines model for HostUpdate.
type HostUpdate struct {
	// Active Whether the host is active for testing
	Active *bool `json:"active,omitempty"`

	// Description Optional description of the host
	Description *string `json:"description,omitempty"`

	// Hostname Hostname or IP address
	Hostname string `json:"hostname"`

	// Name Human-readable name for the host
	Name string `json:"name"`

	// Port Port number for iperf3 server
	Port int `json:"port"`

	// Type Type of host for categorizing network tests
	Type HostType `json:"type"`
}

// IperfTestResult defines model for IperfTestResult.
type IperfTestResult struct {
	// CreatedAt When the result was stored in the system
	CreatedAt time.Time `json:"created_at"`

	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DurationSeconds Test duration in seconds
	DurationSeconds int `json:"duration_seconds"`

	// ErrorMessage Error message if test failed
	ErrorMessage *string `json:"error_message,omitempty"`
	Host         Host    `json:"host"`

	// HostId ID of the target host
	HostId int `json:"host_id"`

	// Id Unique identifier for the test result
	Id int `json:"id"`

	// MeanRttMs Mean round-trip time in milliseconds
	MeanRttMs *float64 `json:"mean_rtt_ms,omitempty"`

	// Protocol Protocol used for the test
	Protocol IperfTestResultProtocol `json:"protocol"`

	// ReceivedMbps Received throughput in Mbps
	ReceivedMbps float64 `json:"received_mbps"`

	// Retransmits Number of retransmitted packets
	Retransmits *float64 `json:"retransmits,omitempty"`

	// SentMbps Sent throughput in Mbps
	SentMbps float64 `json:"sent_mbps"`

	// Success Whether the test was successful
	Success *bool `json:"success,omitempty"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`
}

// IperfTestResultProtocol Protocol used for the test
type IperfTestResultProtocol string

// IperfTestSubmission defines model for IperfTestSubmission.
type IperfTestSubmission struct {
	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DurationSeconds Test duration in seconds
	DurationSeconds int `json:"duration_seconds"`

	// HostId ID of the target host
	HostId int `json:"host_id"`

	// MeanRttMs Mean round-trip time in milliseconds
	MeanRttMs *float64 `json:"mean_rtt_ms,omitempty"`

	// Protocol Protocol used for the test
	Protocol IperfTestSubmissionProtocol `json:"protocol"`

	// ReceivedMbps Received throughput in Mbps
	ReceivedMbps float64 `json:"received_mbps"`

	// Retransmits Number of retransmitted packets
	Retransmits *float64 `json:"retransmits,omitempty"`

	// SentMbps Sent throughput in Mbps
	SentMbps float64 `json:"sent_mbps"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`
}

// IperfTestSubmissionProtocol Protocol used for the test
type IperfTestSubmissionProtocol string

// SpeedTestResult defines model for SpeedTestResult.
type SpeedTestResult struct {
	// CreatedAt When the result was stored in the system
	CreatedAt time.Time `json:"created_at"`

	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DownloadMbps Download speed in Mbps
	DownloadMbps float64 `json:"download_mbps"`

	// ExternalIp External IP address used for the test
	ExternalIp *string `json:"external_ip,omitempty"`

	// Id Unique identifier for the test result
	Id int `json:"id"`

	// Isp Internet Service Provider
	Isp *string `json:"isp,omitempty"`

	// JitterMs Jitter in milliseconds
	JitterMs *float64 `json:"jitter_ms,omitempty"`

	// PingMs Ping latency in milliseconds
	PingMs float64 `json:"ping_ms"`

	// ResultUrl URL to full test results
	ResultUrl *string `json:"result_url,omitempty"`

	// ServerId Speed test server ID
	ServerId *string `json:"server_id,omitempty"`

	// ServerName Speed test server name
	ServerName *string `json:"server_name,omitempty"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`

	// UploadMbps Upload speed in Mbps
	UploadMbps float64 `json:"upload_mbps"`
}

// SpeedTestSubmission defines model for SpeedTestSubmission.
type SpeedTestSubmission struct {
	// DaemonId Identifier of the daemon that performed the test
	DaemonId string `json:"daemon_id"`

	// DownloadMbps Download speed in Mbps
	DownloadMbps float64 `json:"download_mbps"`

	// ExternalIp External IP address used for the test
	ExternalIp *string `json:"external_ip,omitempty"`

	// Isp Internet Service Provider
	Isp *string `json:"isp,omitempty"`

	// JitterMs Jitter in milliseconds
	JitterMs *float64 `json:"jitter_ms,omitempty"`

	// PingMs Ping latency in milliseconds
	PingMs float64 `json:"ping_ms"`

	// ResultUrl URL to full test results
	ResultUrl *string `json:"result_url,omitempty"`

	// ServerId Speed test server ID
	ServerId *string `json:"server_id,omitempty"`

	// ServerName Speed test server name
	ServerName *string `json:"server_name,omitempty"`

	// Timestamp When the test was performed (RFC3339)
	Timestamp time.Time `json:"timestamp"`

	// UploadMbps Upload speed in Mbps
	UploadMbps float64 `json:"upload_mbps"`
}

// GetHostsParams defines parameters for GetHosts.
type GetHostsParams struct {
	// Type Filter by host type
	Type *HostType `form:"type,omitempty" json:"type,omitempty"`

	// Active Filter by active status
	Active *bool `form:"active,omitempty" json:"active,omitempty"`
}

// GetIperfTestsParams defines parameters for GetIperfTests.
type GetIperfTestsParams struct {
	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of results to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// StartTime Filter results after this timestamp (RFC3339)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime Filter results before this timestamp (RFC3339)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// HostId Filter by host ID
	HostId *int `form:"host_id,omitempty" json:"host_id,omitempty"`

	// DaemonId Filter by daemon ID
	DaemonId *string `form:"daemon_id,omitempty" json:"daemon_id,omitempty"`

	// HostName Filter by host name (partial match)
	HostName *string `form:"host_name,omitempty" json:"host_name,omitempty"`

	// HostType Filter by host type
	HostType *HostType `form:"host_type,omitempty" json:"host_type,omitempty"`

	// Slowest Sort by slowest results first
	Slowest *bool `form:"slowest,omitempty" json:"slowest,omitempty"`
}

// GetSpeedTestsParams defines parameters for GetSpeedTests.
type GetSpeedTestsParams struct {
	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of results to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// StartTime Filter results after this timestamp (RFC3339)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime Filter results before this timestamp (RFC3339)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// DaemonId Filter by daemon ID
	DaemonId *string `form:"daemon_id,omitempty" json:"daemon_id,omitempty"`

	// ServerName Filter by server name (partial match)
	ServerName *string `form:"server_name,omitempty" json:"server_name,omitempty"`

	// Slowest Sort by slowest results first
	Slowest *bool `form:"slowest,omitempty" json:"slowest,omitempty"`
}

// AddHostJSONRequestBody defines body for AddHost for application/json ContentType.
type AddHostJSONRequestBody = HostCreation

// UpdateHostJSONRequestBody defines body for UpdateHost for application/json ContentType.
type UpdateHostJSONRequestBody = HostUpdate

// SubmitIperfTestJSONRequestBody defines body for SubmitIperfTest for application/json ContentType.
type SubmitIperfTestJSONRequestBody = IperfTestSubmission

// SubmitSpeedTestJSONRequestBody defines body for SubmitSpeedTest for application/json ContentType.
type SubmitSpeedTestJSONRequestBody = SpeedTestSubmission

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get dashboard data
	// (GET /dashboard)
	GetDashboard(ctx echo.Context) error
	// Get iperf test hosts
	// (GET /hosts)
	GetHosts(ctx echo.Context, params GetHostsParams) error
	// Add new host
	// (POST /hosts)
	AddHost(ctx echo.Context) error
	// Delete host
	// (DELETE /hosts/{hostId})
	DeleteHost(ctx echo.Context, hostId int) error
	// Get host by ID
	// (GET /hosts/{hostId})
	GetHost(ctx echo.Context, hostId int) error
	// Update host
	// (PUT /hosts/{hostId})
	UpdateHost(ctx echo.Context, hostId int) error
	// Get iperf test results
	// (GET /iperf/results)
	GetIperfTests(ctx echo.Context, params GetIperfTestsParams) error
	// Submit iperf test results
	// (POST /iperf/results)
	SubmitIperfTest(ctx echo.Context) error
	// Delete iperf test result
	// (DELETE /iperf/results/{testId})
	DeleteIperfTest(ctx echo.Context, testId int) error
	// Get speed test results
	// (GET /speedtest/results)
	GetSpeedTests(ctx echo.Context, params GetSpeedTestsParams) error
	// Submit speed test results
	// (POST /speedtest/results)
	SubmitSpeedTest(ctx echo.Context) error
	// Delete speed test result
	// (DELETE /speedtest/results/{testId})
	DeleteSpeedTest(ctx echo.Context, testId int) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetDashboard converts echo context to params.
func (w *ServerInterfaceWrapper) GetDashboard(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDashboard(ctx)
	return err
}

// GetHosts converts echo context to params.
func (w *ServerInterfaceWrapper) GetHosts(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetHostsParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHosts(ctx, params)
	return err
}

// AddHost converts echo context to params.
func (w *ServerInterfaceWrapper) AddHost(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddHost(ctx)
	return err
}

// DeleteHost converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteHost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hostId" -------------
	var hostId int

	err = runtime.BindStyledParameterWithOptions("simple", "hostId", ctx.Param("hostId"), &hostId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hostId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteHost(ctx, hostId)
	return err
}

// GetHost converts echo context to params.
func (w *ServerInterfaceWrapper) GetHost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hostId" -------------
	var hostId int

	err = runtime.BindStyledParameterWithOptions("simple", "hostId", ctx.Param("hostId"), &hostId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hostId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHost(ctx, hostId)
	return err
}

// UpdateHost converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateHost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hostId" -------------
	var hostId int

	err = runtime.BindStyledParameterWithOptions("simple", "hostId", ctx.Param("hostId"), &hostId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hostId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateHost(ctx, hostId)
	return err
}

// GetIperfTests converts echo context to params.
func (w *ServerInterfaceWrapper) GetIperfTests(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIperfTestsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "host_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "host_id", ctx.QueryParams(), &params.HostId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host_id: %s", err))
	}

	// ------------- Optional query parameter "daemon_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "daemon_id", ctx.QueryParams(), &params.DaemonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daemon_id: %s", err))
	}

	// ------------- Optional query parameter "host_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "host_name", ctx.QueryParams(), &params.HostName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host_name: %s", err))
	}

	// ------------- Optional query parameter "host_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "host_type", ctx.QueryParams(), &params.HostType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host_type: %s", err))
	}

	// ------------- Optional query parameter "slowest" -------------

	err = runtime.BindQueryParameter("form", true, false, "slowest", ctx.QueryParams(), &params.Slowest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slowest: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIperfTests(ctx, params)
	return err
}

// SubmitIperfTest converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitIperfTest(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitIperfTest(ctx)
	return err
}

// DeleteIperfTest converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteIperfTest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "testId" -------------
	var testId int

	err = runtime.BindStyledParameterWithOptions("simple", "testId", ctx.Param("testId"), &testId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter testId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteIperfTest(ctx, testId)
	return err
}

// GetSpeedTests converts echo context to params.
func (w *ServerInterfaceWrapper) GetSpeedTests(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSpeedTestsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "daemon_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "daemon_id", ctx.QueryParams(), &params.DaemonId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter daemon_id: %s", err))
	}

	// ------------- Optional query parameter "server_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "server_name", ctx.QueryParams(), &params.ServerName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter server_name: %s", err))
	}

	// ------------- Optional query parameter "slowest" -------------

	err = runtime.BindQueryParameter("form", true, false, "slowest", ctx.QueryParams(), &params.Slowest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slowest: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSpeedTests(ctx, params)
	return err
}

// SubmitSpeedTest converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitSpeedTest(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitSpeedTest(ctx)
	return err
}

// DeleteSpeedTest converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSpeedTest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "testId" -------------
	var testId int

	err = runtime.BindStyledParameterWithOptions("simple", "testId", ctx.Param("testId"), &testId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter testId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSpeedTest(ctx, testId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/dashboard", wrapper.GetDashboard)
	router.GET(baseURL+"/hosts", wrapper.GetHosts)
	router.POST(baseURL+"/hosts", wrapper.AddHost)
	router.DELETE(baseURL+"/hosts/:hostId", wrapper.DeleteHost)
	router.GET(baseURL+"/hosts/:hostId", wrapper.GetHost)
	router.PUT(baseURL+"/hosts/:hostId", wrapper.UpdateHost)
	router.GET(baseURL+"/iperf/results", wrapper.GetIperfTests)
	router.POST(baseURL+"/iperf/results", wrapper.SubmitIperfTest)
	router.DELETE(baseURL+"/iperf/results/:testId", wrapper.DeleteIperfTest)
	router.GET(baseURL+"/speedtest/results", wrapper.GetSpeedTests)
	router.POST(baseURL+"/speedtest/results", wrapper.SubmitSpeedTest)
	router.DELETE(baseURL+"/speedtest/results/:testId", wrapper.DeleteSpeedTest)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//8er0nu1T8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
